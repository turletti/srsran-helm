apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "srsran-ue.fullname" . }}-{{ .Release.Name }}-ue-config
  labels:
    {{- include "srsran-ue.labels" . | nindent 4 }}
data:
  start_ue.sh: |
    #!/bin/bash
    ## Bash file to start the UE using /opt/srsRAN_4G/build/srsue/src/srsue /srsran/config/ue1.conf
    ## The UE number is passed as an argument to the script

    python3 /srsran/config/generate_ue_conf.py $1 /tmp/
    # ip netns add ue$1
    /opt/srsRAN_4G/build/srsue/src/srsue /tmp/ue_$1.conf

  start_gnu.sh: |
    #!/bin/bash
    python3 /srsran/config/multi_ue_scenario.py -n $1

  generate_ue_conf.py: |
    #!/usr/bin/env python3
    import argparse
    import os

    K_HEX = "fec86ba6eb707ed08905757b1bb44b8f"
    OPC_HEX = "C42449363BBAD02B66D16BC975D77CC1"

    UE_TEMPLATE = """[rf]
    freq_offset = 0
    tx_gain = 80
    rx_gain = 40
    srate = 23.04e6
    nof_antennas = 1

    device_name = zmq
    device_args = tx_port={tx_port},rx_port={rx_port},base_srate=23.04e6

    [rat.eutra]
    dl_earfcn = 2850
    nof_carriers = 0

    [rat.nr]
    bands = 3
    nof_carriers = 1
    max_nof_prb = 106
    nof_prb = 106

    [log]
    all_level = warning
    phy_lib_level = none
    all_hex_limit = 32
    filename = {log_file}
    file_max_size = 1000

    [usim]
    mode = soft
    algo = milenage
    opc  = {opc}
    k    = {k}
    imsi = {imsi}
    imei = 356938035643803

    [rrc]
    release = 15
    ue_category = 4

    [nas]
    apn = {apn}
    apn_protocol = ipv4

    [gw]
    netns = {netns}
    ip_devname = tun_srsue
    ip_netmask = 255.255.255.0

    [gui]
    enable = false
    """

    def imsi_for(ue_number: int) -> str:
        return f"0010100000000{ue_number:02d}"

    def apn_for(ue_number: int) -> str:
        return "internet" if ue_number % 2 == 1 else "streaming"

    def generate_ue_config(ue_number: int, output_directory: str) -> str:
        os.makedirs(output_directory, exist_ok=True)

        # Logique corrigée : 
        # tx_port : l'UE bind sur sa propre interface (ueIp)
        # rx_port : l'UE reçoit du gNB (gnbIp)
        cfg = UE_TEMPLATE.format(
            tx_port=f"tcp://{{ .Values.ueIp }}:2001",
            rx_port=f"tcp://{{ .Values.gnbIp }}:2000",
            log_file=os.path.join(output_directory, f"ue{ue_number}.log"),
            opc=OPC_HEX,
            k=K_HEX,
            imsi=imsi_for(ue_number),
            apn=apn_for(ue_number),
            netns=f"ue{ue_number}",
        )
    def generate_ue_config(ue_number: int, output_directory: str) -> str:
        os.makedirs(output_directory, exist_ok=True)

        cfg = UE_TEMPLATE.format(
            # Utilisation des valeurs injectées par Helm/Ansible
            tx_port=f"tcp://{{ .Values.ueIp }}:{{ .Values.zmq.tx_port }}",
            rx_port=f"tcp://{{ .Values.gnbIp }}:{{ .Values.zmq.rx_port }}",
            log_file=os.path.join(output_directory, f"ue{ue_number}.log"),
            opc="{{ .Values.opc }}",
            k="{{ .Values.k }}",
            imsi="{{ .Values.imsi }}",
            apn="{{ .Values.apn }}",
            netns=f"ue{ue_number}",
        )
        path = os.path.join(output_directory, f"ue_{ue_number}.conf")
        with open(path, "w") as f:
            f.write(cfg)
        print(f"Wrote {path}")
        return path

    if __name__ == '__main__':
        parser = argparse.ArgumentParser(description='Generate hardcoded UE configuration files.')
        parser.add_argument('ue_number', type=int, help='UE number (e.g., 6 -> IMSI ...000006)')
        parser.add_argument('output_directory', type=str, help='Directory to save the UE configuration')
        args = parser.parse_args()
        generate_ue_config(args.ue_number, args.output_directory)

  multi_ue_scenario.py: |
    #!/usr/bin/env python3
    # -*- coding: utf-8 -*-
    from gnuradio import blocks, gr, zeromq
    import sys, signal
    from argparse import ArgumentParser

    class multi_ue_scenario(gr.top_block):
        def __init__(self, num_ues):
            gr.top_block.__init__(self, "srsRAN_multi_UE")

            zmq_timeout = 100
            zmq_hwm = -1
            samp_rate = 23040000
            slow_down_ratio = 1

            self.zeromq_req_source_0 = zeromq.req_source(gr.sizeof_gr_complex, 1, 'tcp://{{ .Values.gnbIp }}:2000', zmq_timeout, False, zmq_hwm)
            self.zeromq_rep_sink_0_1 = zeromq.rep_sink(gr.sizeof_gr_complex, 1, 'tcp://{{ .Values.ueIp }}:2001', zmq_timeout, False, zmq_hwm)

            self.zeromq_req_sources = []
            self.zeromq_rep_sinks = []
            self.blocks_throttle = blocks.throttle(gr.sizeof_gr_complex*1, samp_rate / slow_down_ratio, True)
            self.blocks_add_xx = blocks.add_vcc(1)

            for i in range(num_ues):
                req_port = 2101 + i
                rep_port = 2201 + i
                req_source = zeromq.req_source(gr.sizeof_gr_complex, 1, f'tcp://{{ .Values.ueIp }}:{req_port}', zmq_timeout, False, zmq_hwm)
                rep_sink = zeromq.rep_sink(gr.sizeof_gr_complex, 1, f'tcp://{{ .Values.ueIp }}:{rep_port}', zmq_timeout, False, zmq_hwm)
                self.zeromq_req_sources.append(req_source)
                self.zeromq_rep_sinks.append(rep_sink)
                self.connect((req_source, 0), (self.blocks_add_xx, i))
                self.connect((self.blocks_throttle, 0), (rep_sink, 0))

            self.connect((self.blocks_add_xx, 0), (self.zeromq_rep_sink_0_1, 0))
            self.connect((self.zeromq_req_source_0, 0), (self.blocks_throttle, 0))

    def main():
        parser = ArgumentParser(description='srsRAN_multi_UE setup')
        parser.add_argument('-n', '--num-ues', type=int, required=True, help='Number of UEs')
        args = parser.parse_args()
        tb = multi_ue_scenario(args.num_ues)

        def sig_handler(sig=None, frame=None):
            tb.stop()
            tb.wait()
            sys.exit(0)

        signal.signal(signal.SIGINT, sig_handler)
        signal.signal(signal.SIGTERM, sig_handler)

        tb.start()

        try:
            input('Press Enter to quit: ')
        except EOFError:
            pass
        tb.stop()
        tb.wait()

    if __name__ == '__main__':
        main()
